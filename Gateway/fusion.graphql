schema
  @fusion(version: 1)
  @transport(subgraph: "files", group: "Fusion", location: "http:\/\/localhost:1002\/graphql", kind: "HTTP")
  @transport(subgraph: "users", group: "Fusion", location: "http:\/\/localhost:1001\/graphql", kind: "HTTP") {
  query: Query
  mutation: Mutation
}

type Query {
  fileById(id: UUID!): FileEntity
    @variable(subgraph: "files", name: "id", argument: "id")
    @resolver(subgraph: "files", select: "{ fileById(id: $id) }", arguments: [ { name: "id", type: "UUID!" } ])
  files(order: [FileEntitySortInput!] skip: Int take: Int where: FileEntityFilterInput): FilesCollectionSegment
    @variable(subgraph: "files", name: "order", argument: "order")
    @variable(subgraph: "files", name: "skip", argument: "skip")
    @variable(subgraph: "files", name: "take", argument: "take")
    @variable(subgraph: "files", name: "where", argument: "where")
    @resolver(subgraph: "files", select: "{ files(order: $order, skip: $skip, take: $take, where: $where) }", arguments: [ { name: "order", type: "[FileEntitySortInput!]" }, { name: "skip", type: "Int" }, { name: "take", type: "Int" }, { name: "where", type: "FileEntityFilterInput" } ])
  userById(id: UUID!): UserEntity
    @variable(subgraph: "users", name: "id", argument: "id")
    @resolver(subgraph: "users", select: "{ userById(id: $id) }", arguments: [ { name: "id", type: "UUID!" } ])
  users(order: [UserEntitySortInput!] skip: Int take: Int where: UserEntityFilterInput): UsersCollectionSegment
    @variable(subgraph: "users", name: "order", argument: "order")
    @variable(subgraph: "users", name: "skip", argument: "skip")
    @variable(subgraph: "users", name: "take", argument: "take")
    @variable(subgraph: "users", name: "where", argument: "where")
    @resolver(subgraph: "users", select: "{ users(order: $order, skip: $skip, take: $take, where: $where) }", arguments: [ { name: "order", type: "[UserEntitySortInput!]" }, { name: "skip", type: "Int" }, { name: "take", type: "Int" }, { name: "where", type: "UserEntityFilterInput" } ])
}

type Mutation {
  createFile(input: CreateFileInput!): FileEntity!
    @variable(subgraph: "files", name: "input", argument: "input")
    @resolver(subgraph: "files", select: "{ createFile(input: $input) }", arguments: [ { name: "input", type: "CreateFileInput!" } ])
  createUser(input: CreateUserInput!): UserEntity!
    @variable(subgraph: "users", name: "input", argument: "input")
    @resolver(subgraph: "users", select: "{ createUser(input: $input) }", arguments: [ { name: "input", type: "CreateUserInput!" } ])
  deleteFile(id: UUID!): FileEntity!
    @variable(subgraph: "files", name: "id", argument: "id")
    @resolver(subgraph: "files", select: "{ deleteFile(id: $id) }", arguments: [ { name: "id", type: "UUID!" } ])
  deleteUser(id: UUID!): UserEntity!
    @variable(subgraph: "users", name: "id", argument: "id")
    @resolver(subgraph: "users", select: "{ deleteUser(id: $id) }", arguments: [ { name: "id", type: "UUID!" } ])
  updateFile(input: UpdateFileInput!): FileEntity!
    @variable(subgraph: "files", name: "input", argument: "input")
    @resolver(subgraph: "files", select: "{ updateFile(input: $input) }", arguments: [ { name: "input", type: "UpdateFileInput!" } ])
  updateUser(input: UpdateUserInput!): UserEntity!
    @variable(subgraph: "users", name: "input", argument: "input")
    @resolver(subgraph: "users", select: "{ updateUser(input: $input) }", arguments: [ { name: "input", type: "UpdateUserInput!" } ])
}

"Information about the offset pagination."
type CollectionSegmentInfo {
  "Indicates whether more items exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
    @source(subgraph: "files")
    @source(subgraph: "users")
  "Indicates whether more items exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
    @source(subgraph: "files")
    @source(subgraph: "users")
}

type FileEntity {
  id: UUID!
    @source(subgraph: "files")
  name: String!
    @source(subgraph: "files")
  user: UserEntity!
    @source(subgraph: "users")
  userId: UUID!
    @source(subgraph: "files")
}

"A segment of a collection."
type FilesCollectionSegment {
  "A flattened list of the items."
  items: [FileEntity!]
    @source(subgraph: "files")
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
    @source(subgraph: "files")
}

type UserEntity {
  id: UUID!
    @source(subgraph: "users")
  name: String!
    @source(subgraph: "users")
  sex: Sex!
    @source(subgraph: "users")
}

"A segment of a collection."
type UsersCollectionSegment {
  "A flattened list of the items."
  items: [UserEntity!]
    @source(subgraph: "users")
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
    @source(subgraph: "users")
}

input CreateFileInput {
  name: String!
  userId: UUID!
}

input CreateUserInput {
  name: String!
  sex: Sex!
}

input FileEntityFilterInput {
  and: [FileEntityFilterInput!]
  id: UuidOperationFilterInput
  name: StringOperationFilterInput
  or: [FileEntityFilterInput!]
  userId: UuidOperationFilterInput
}

input FileEntitySortInput {
  id: SortEnumType
  name: SortEnumType
  userId: SortEnumType
}

input SexOperationFilterInput {
  eq: Sex
  in: [Sex!]
  neq: Sex
  nin: [Sex!]
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  contains: String
  endsWith: String
  eq: String
  in: [String]
  ncontains: String
  nendsWith: String
  neq: String
  nin: [String]
  nstartsWith: String
  or: [StringOperationFilterInput!]
  startsWith: String
}

input UpdateFileInput {
  id: UUID!
  name: String
}

input UpdateUserInput {
  id: UUID!
  name: String
  sex: Sex!
}

input UserEntityFilterInput {
  and: [UserEntityFilterInput!]
  id: UuidOperationFilterInput
  name: StringOperationFilterInput
  or: [UserEntityFilterInput!]
  sex: SexOperationFilterInput
}

input UserEntitySortInput {
  id: SortEnumType
  name: SortEnumType
  sex: SortEnumType
}

input UuidOperationFilterInput {
  eq: UUID
  gt: UUID
  gte: UUID
  in: [UUID]
  lt: UUID
  lte: UUID
  neq: UUID
  ngt: UUID
  ngte: UUID
  nin: [UUID]
  nlt: UUID
  nlte: UUID
}

enum Sex {
  FEMALE
    @source(subgraph: "users")
  MALE
    @source(subgraph: "users")
}

enum SortEnumType {
  ASC
    @source(subgraph: "files")
    @source(subgraph: "users")
  DESC
    @source(subgraph: "files")
    @source(subgraph: "users")
}

scalar UUID